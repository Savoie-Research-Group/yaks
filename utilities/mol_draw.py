from taffi_functions import *
from utility import *
import sys
import numpy as np
def mol_draw(elements, geo, q_tot=0):
    for count_i, i in enumerate(elements):
        print('{} {} {} {}'.format(i, geo[count_i][0], geo[count_i][1], geo[count_i][2]))
    adj_mat=Table_generator(elements, geo)
    bond_matrix, _=find_lewis(elements, adj_mat, q=q_tot)
    lones, charges, bonding_electrons, core_electrons=count_bond_matrix(elements, bond_matrix)
    #print(len(bond_matrix))
    structs=np.shape(lones)[0]
    for k in range(structs):
        lone=lones[k]
        keep_lone=[ count_j for count_j,j in enumerate(lone) if j%2 != 0]
        #print(keep_lone)
        fc=list(charges[k])
        chrg=len([i for i in fc if i != 0])
        bond_mat=bond_matrix[k]
        #print(chrg)
        with open('{}.mol'.format(k), 'w+') as f:
            f.write('{}\nGenerated by mol_write.py\n\n'.format(k))
            f.write("{:>3d}{:>3d}  0  0  0  0  0  0  0  0999 V2000\n".format(len(elements),int(np.sum(adj_mat/2.0))))
            for count_i,i in enumerate(elements):
                f.write(" {:> 9.4f} {:> 9.4f} {:> 9.4f} {:<3s} 0  0  0  0  0  0  0  0  0  0  0  0\n".format(geo[count_i][0],geo[count_i][1],geo[count_i][2],i))
            bonds = [ (count_i,count_j) for count_i,i in enumerate(adj_mat) for count_j,j in enumerate(i) if j == 1 and count_j > count_i ] 
            for i in bonds:
                bond_order = int(bond_mat[i[0],i[1]])
                f.write("{:>3d}{:>3d}{:>3d}  0  0  0  0\n".format(i[0]+1,i[1]+1,bond_order))
            # write radical info if exist
            if len(keep_lone) > 0:
                if len(keep_lone) == 1:
                    f.write("M  RAD{:>3d}{:>4d}{:>4d}\n".format(1,keep_lone[0]+1,2))
                elif len(keep_lone) == 2:
                    f.write("M  RAD{:>3d}{:>4d}{:>4d}{:>4d}{:>4d}\n".format(2,keep_lone[0]+1,2,keep_lone[1]+1,2))
                else:
                    print("Only support one/two radical containing compounds, radical info will be skip in the output mol file...")
            if chrg > 0:
                if chrg == 1:
                    charge = [i for i in fc if i != 0][0]
                    f.write("M  CHG{:>3d}{:>4d}{:>4d}\n".format(1,int(fc.index(charge)+1),int(charge)))
                else:
                    info = "M  CHG{:>3d}".format(chrg)
                    for count_c,charge in enumerate(fc):
                        if charge != 0: info += '{:>4d}{:>4d}'.format(count_c+1,int(charge))
                    info += '\n'
                    f.write(info)
            f.write("M  END\n$$$$\n")
    for k in range(structs):
        from rdkit import Chem
        from rdkit.Chem import Draw
        from rdkit.Chem import AllChem
        mol=Chem.MolFromMolFile('{}.mol'.format(k), sanitize=False)
        AllChem.EmbedMolecule(mol)
        Draw.MolToFile(mol, '{}.png'.format(k))
    return 

def main(input_file): 
    # read xyz file. NOTE: if you expect the compound should be ion, please specify the charge state in xyz file
    q=parse_q(input_file)
    elements, geo=xyz_parse(input_file)
    mol_draw(elements, geo, q_tot=q)
if __name__ == "__main__":
   main(sys.argv[1]) 
